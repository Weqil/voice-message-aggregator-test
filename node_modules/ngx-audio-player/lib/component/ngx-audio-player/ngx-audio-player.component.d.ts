import { OnInit, ElementRef, OnChanges, SimpleChanges, EventEmitter } from '@angular/core';
import { Track } from '../../model/track.model';
import { MatSlider } from '@angular/material/slider';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { AudioPlayerService } from '../../service/audio-player-service/audio-player.service';
import * as i0 from "@angular/core";
declare class EventResponse {
    event: string;
    track: Track;
}
export declare class AudioPlayerComponent implements OnInit, OnChanges {
    audioPlayerService: AudioPlayerService;
    constructor(elem: ElementRef);
    set playlist(playlist: Track[]);
    set matPaginator(mp: MatPaginator);
    displayedColumns: string[];
    dataSource: MatTableDataSource<Track>;
    paginator: MatPaginator;
    timeLineDuration: MatSlider;
    mediaType: string;
    tracks: Track[];
    repeat: "all" | "one" | "none";
    displayTitle: boolean;
    displayPlaylist: boolean;
    displayVolumeControls: boolean;
    displayVolumeSlider: boolean;
    displayRepeatControls: boolean;
    pageSizeOptions: number[];
    expanded: boolean;
    autoPlay: boolean;
    disablePositionSlider: boolean;
    displayArtist: boolean;
    displayDuration: boolean;
    tableHeader: string;
    titleHeader: string;
    artistHeader: string;
    durationHeader: string;
    currentIndex: number;
    trackPlaying: EventEmitter<EventResponse>;
    trackPaused: EventEmitter<EventResponse>;
    trackEnded: EventEmitter<EventResponse>;
    nextTrackRequested: EventEmitter<EventResponse>;
    previousTrackRequested: EventEmitter<EventResponse>;
    trackSelected: EventEmitter<EventResponse>;
    player: ElementRef;
    iOS: boolean;
    loaderDisplay: boolean;
    isPlaying: boolean;
    currentTime: number;
    volume: number;
    toggledVolume: number;
    duration: number;
    private startOffsetValue;
    set startOffset(seconds: number);
    get startOffset(): number;
    endOffset: number;
    /**
     * Allow to start the current track
     */
    play(): void;
    /**
     * Allow to pause the current track
     */
    pause(): void;
    /**
     * Allow to stop the current track
     */
    stop(): void;
    currTimePosChanged(event: any): void;
    currVolumeChanged(event: any): void;
    bindPlayerEvent(): void;
    emitEventResponse(event: string, emitter: EventEmitter<EventResponse>): void;
    playBtnHandler(): void;
    triggerPlay(track?: Track): void;
    toggleVolume(): void;
    toggleRepeat(): void;
    private setVolume;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private buildDisplayedColumns;
    initialize(): void;
    setDataSourceAttributes(): void;
    nextSong(): void;
    previousSong(): void;
    resetSong(): void;
    selectTrack(index: number): void;
    checkIfSongHasStartedSinceAtleastTwoSeconds(): boolean;
    updateCurrentTrack(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AudioPlayerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AudioPlayerComponent, "mat-advanced-audio-player,ngx-audio-player", never, { "playlist": "playlist"; "repeat": "repeat"; "displayTitle": "displayTitle"; "displayPlaylist": "displayPlaylist"; "displayVolumeControls": "displayVolumeControls"; "displayVolumeSlider": "displayVolumeSlider"; "displayRepeatControls": "displayRepeatControls"; "pageSizeOptions": "pageSizeOptions"; "expanded": "expanded"; "autoPlay": "autoPlay"; "disablePositionSlider": "disablePositionSlider"; "displayArtist": "displayArtist"; "displayDuration": "displayDuration"; "tableHeader": "tableHeader"; "titleHeader": "titleHeader"; "artistHeader": "artistHeader"; "durationHeader": "durationHeader"; "startOffset": "startOffset"; "endOffset": "endOffset"; "play": "play"; "pause": "pause"; "stop": "stop"; }, { "trackPlaying": "trackPlaying"; "trackPaused": "trackPaused"; "trackEnded": "trackEnded"; "nextTrackRequested": "nextTrackRequested"; "previousTrackRequested": "previousTrackRequested"; "trackSelected": "trackSelected"; }, never, never>;
}
export {};
